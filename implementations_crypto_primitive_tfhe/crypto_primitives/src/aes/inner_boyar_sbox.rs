use core::panic;
use std::collections::HashSet;
use std::default;
use std::{collections::HashMap, time::Instant};
use std::fs::File;
use csv::ReaderBuilder;

use rayon::prelude::{IntoParallelRefIterator, ParallelIterator};

use tfhe::gadget::{prelude::*, client_key};

use crate::utils::vec_bool_to_int;

use super::aes_utils::pretty_print_encrypted;


// A structure storing the homomorphic implementation of the non linear par tof the Boyar S-box.
pub struct NonLinearSBox{
    pub gadgets : HashMap<String, Gadget>,
    pub leaves : HashMap<String, Vec<String>>,
    pub topological_order : Vec<Vec<String>>
}



impl NonLinearSBox{
    // Parse a file generated by the script of decomposition of s-box and create the corresponding structure of gadgets.
    pub fn parse_file(file_path : &str) -> Self {
        // Open the CSV file
        let file = File::open(file_path).unwrap();
    
        // Create a CSV reader with flexible options
        let mut rdr = ReaderBuilder::new()
            .has_headers(false)
            .delimiter(b';') // Set to false if your CSV file doesn't have headers
            .from_reader(file);
    
        // Storing the results in maps, as well as the topological order in a vec
        let mut topological_order:Vec<Vec<String>> = vec![vec![]];
        let mut all_q_ins : HashMap<String, Vec<u32>> = HashMap::new();
        let mut all_leaves : HashMap<String, Vec<String>> = HashMap::new();
        let mut all_p : HashMap<String, u32> = HashMap::new();
        let mut all_truth_tables : HashMap<String, Vec<bool>> = HashMap::new();
    
        // Iterate over each record in the CSV file
        for result in rdr.records() {
            // Unwrap the result or handle the error if there is one
            let record = result.unwrap();
            
            let name = String::from(&record[0]);
        
            if record[1].starts_with('[') && record[1].ends_with(']') {
                let inner_str = &record[1][1..record[1].len() - 1];
    
                let qs_in = inner_str
                    .split(',')
                    .map(|s| s.trim().parse().unwrap())
                    .filter(|x| *x > 0)
                    .collect();
                // println!("all_qs : {:?}", qs_in);
    
                all_q_ins.insert(name.clone(),  qs_in);
            }
            else {
                panic!("Invalid input format: Must start and end with square brackets.");
            }
    
           
            if record[2].starts_with('[') && record[2].ends_with(']') {
                // Remove the square brackets
                let inner_str = &record[2][1..record[2].len() - 1];
        
                // Split the inner string by commas and trim whitespace
                let leaves: Vec<String> = inner_str
                    .split(',')
                    .enumerate()
                    .map(|(_, s)| {
                        let mut parts = s.trim().trim_matches('\'').trim().split('_');
                        parts.next().unwrap_or("").to_owned()
                    })
                    .map(String::from)
                    .collect();
                
                // println!("leaves : {:?}", leaves);
    
                all_leaves.insert(name.clone(),  leaves);
    
            } else {
                panic!("Invalid input format: Must start and end with square brackets.");
            }
     
            let p : u32 = record[3].parse().unwrap_or(0);
            all_p.insert(name.clone(), p);         
    
            if record[4].starts_with('[') && record[4].ends_with(']') {
                // Remove the square brackets
                let inner_str = &record[4][1..record[4].len() - 1];
        
                // Split the inner string by commas and trim whitespace
                let truth_table: Vec<bool> = inner_str
                    .split(',')
                    .map(|s| {
                        s.trim().eq(&'1'.to_string())
                    })
                    .collect();
      
                all_truth_tables.insert(name.clone(),  truth_table);
    
            } else {
                panic!("Invalid input format: Must start and end with square brackets.");
            }
               
            //Rangement dans l'ordre topologique (avec égalités)
            let l = topological_order.len();
            if all_leaves[&name].iter().any(|leaf| topological_order[l - 1].contains(leaf)){
                topological_order.push(vec![name.clone()]);
            }
            else{
                topological_order[l - 1].push(name.clone());
            }
    
        }
    
        //Creation of the Gadgets
        let mut gadgets : HashMap<String, Gadget> = HashMap::new();
        
        for step in &topological_order{
            for name in step{
                gadgets.insert(
                    name.clone(), 
                    Gadget::new_canonical(
                        all_q_ins.get(name).unwrap().to_vec(), 
                        1,
                        *all_p.get(name).unwrap(),
                        if name.contains('z') {2} else {*all_p.get(name).unwrap()},
                        all_q_ins.get(name).unwrap().len() as u32,
                        &(|v : Vec<bool>| all_truth_tables.get(name).unwrap()[vec_bool_to_int(v, true)])
                    )
                );
            }
        }
    
        Self {gadgets, leaves:all_leaves, topological_order}
    }
}


// A structure containing the encrypted state running into the s-box
pub struct NonLinearSboxState{
    pub bits : HashMap<String, HashMap<u32, Ciphertext>>,
    non_linear_s_box : NonLinearSBox
}


impl NonLinearSboxState {


    pub fn new(input : Vec<Ciphertext>, filename : &str, server_key : &ServerKey, client_key_debug : &ClientKey) -> Self{
        let s_box = NonLinearSBox::parse_file(filename);
        assert_eq!(input.len(), 22);
    
        let mut bits: HashMap<String, HashMap<u32, Ciphertext>> = HashMap::new();
    
        // Function to perform modswitch and insert into HashMap
        let mut perform_modswitch = |name: &str, x: &Ciphertext| {
            let map = bits.entry(name.to_string()).or_insert(HashMap::new());
            s_box.gadgets.values().for_each(|gadget| {
                let p = gadget.get_encoding_in(0).get_modulus();
                map.entry(p).or_insert_with(|| Self::modswitch(x, 2, p, server_key, client_key_debug));
            });
        };

        // Processing x7 separately
        perform_modswitch("x7", &input[0]);
    
        // Processing other inputs (y1, y2, ...)
        input.iter().skip(1).enumerate().for_each(|(i, x)| {
            let name = format!("y{}", i + 1);
            perform_modswitch(&name, x);
        });
    
        Self {
            bits,
            non_linear_s_box: s_box,
        }
    }


    fn evaluate_gadget_and_store_result(&self, node : &String, server_key : &ServerKey, client_key_debug : &ClientKey, debug_flag : bool) -> HashMap<u32, Ciphertext> {
        assert!(! self.bits.contains_key(node));
        let gadget = self.non_linear_s_box.gadgets.get(node).unwrap();
        let leaves = self.non_linear_s_box.leaves.get(node).unwrap();
        let p_in = gadget.get_modulus_in();

        let mut input = leaves.iter().map(|s| { 
            assert!(self.bits.get(s).unwrap().contains_key(&p_in));

            self.bits.get(s).unwrap().get(&p_in).cloned().unwrap_or_else(|| {
                let (p_current, c) = self.bits.get(s).unwrap().iter().next().unwrap();
                println!("{}", *p_current);
                Self::modswitch(&c, *p_current, p_in, server_key, client_key_debug)
            }).clone()
        }).collect();

        input = gadget.cast_before_gadget_from_1(input, server_key);
        let result = gadget.exec(&input, server_key);

        if debug_flag{
            // println!("----------------------------");
            // gadget.pretty_print();
            // print!("Sum float : ");
            // let sum_debug : f64 = input.iter().enumerate().map(|(i, c)| client_key_debug.decrypt_float_over_the_torus(c, &gadget.get_encoding_in(i))).map(|f| {print!("{}|", 11.0 * f); f}).sum();
            // println!("{}", sum_debug * 11.0);
            // println!("Flottant : {}", client_key_debug.decrypt_float_over_the_torus(&result, gadget.get_encoding_out()));
            let actual_result = gadget.exec_clear(input.iter().enumerate().map(|(i, c)| client_key_debug.decrypt(c) == 1).collect());
            assert_eq!(actual_result, client_key_debug.decrypt(&result) == 1);
            // println!("----------------------------");
        }

        HashMap::from([(gadget.get_modulus_out(), result)])
    }


    pub fn full_round_boyar(&mut self, server_key : &ServerKey, client_key_debug : &ClientKey, debug_flag : bool){
        for step in self.non_linear_s_box.topological_order.clone(){
            let results : Vec<HashMap<u32, Ciphertext>>= step.par_iter().map(|node| {self.evaluate_gadget_and_store_result(node, server_key, client_key_debug, debug_flag)}).collect();
            results.into_iter().zip(step).for_each(|(r, n)| {self.bits.insert(n, r);});
        }
    }


    pub fn modswitch(input : &Ciphertext, p_in : u32, p_out : u32, server_key : &ServerKey, client_key_debug : &ClientKey) -> Ciphertext {
        if p_in == 2 { Self::modswitch_from_modulus_2(input, p_out, server_key, client_key_debug) }
        else {
            let gadget = Gadget::new_canonical(vec![1], 1, p_in, p_out, 1, &|x| {x[0]});
            gadget.exec(&vec![input.clone()], server_key)
        }
    }


    // can only be used with a odd p_out (just needs to be prime with 2)
    pub fn modswitch_from_modulus_2(input : &Ciphertext, p_out : u32, server_key : &ServerKey, client_key_debug : &ClientKey)-> Ciphertext{
        let enc_out = BooleanEncoding::new(HashSet::from([p_out - 1]), HashSet::from([1]), p_out);
        let gadget = Gadget::new(vec![BooleanEncoding::new_canonical(1, 2)], BooleanEncoding::new_canonical(1, 2), enc_out, 1, &|x| {x[0]});
        // println!("Test started");
        // gadget.test_full(&client_key_debug, &server_key);
        // println!("Test passed");
        let mut current = gadget.exec(&vec![input.clone()], server_key);
        current = server_key.simple_plaintext_sum_encoding(&current, 1, p_out);
        // multiplication by the inverse of 2 in Zp
        let inv_2 = match p_out {
            11 => 6,
            _ => panic!("Hard code this value here")
        };
        let result = server_key.cast_encoding(&current, inv_2);
        // println!("{}", client_key_debug.decrypt_float_over_the_torus(&result, &BooleanEncoding::new_canonical(1, 11)));
        assert_eq!(client_key_debug.decrypt(&input), client_key_debug.decrypt(&result));
        result
    }


    pub fn extract_and_cast_output(&self, server_key : &ServerKey, client_key_debug : &ClientKey) -> Vec<Ciphertext>{
        let mut output = vec![];
        for i in 0..18{
            let (p, c) = self.bits.get(&format!("z{}", i)).unwrap().iter().next().unwrap();
            //output.push(Self::modswitch(c, *p, 2, &server_key, client_key_debug));

            ///Version with no cast (cast embedded in the last gadgets)
            assert_eq!(*p, 2);
            output.push(c.to_owned());
        }
        output
    }


}

